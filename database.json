{
  "posts": [
    {
      "title": "Destrukturyzacja",
      "text": " Jak trafnie stwierdziÅ‚ Kyle Simpson w ksiÄ…Å¼ce ECMAScript 6 i dalej, manualne przypisanie indeksowanej wartoÅ›ci z tablicy lub wÅ‚aÅ›ciwoÅ›ci z obiektu moÅ¼na nazwaÄ‡ przypisaniem strukturalnym. Okej, ale co to ma wspÃ³lnego z tÄ… tajemniczÄ… destrukturyzacjÄ…. PodÄ…Å¼ajÄ…c za wywodem Kyleâ€™a, moÅ¼emy spodziewaÄ‡ siÄ™ operacji o odwrotnym dziaÅ‚aniu do zaprezentowanej w powyÅ¼szym przykÅ‚adzie. Zobaczmy, jak to wyglÄ…da w praktyce. Przy pierwszym kontakcie z takÄ… skÅ‚adniÄ…, jedyne, czego moÅ¼na oczekiwaÄ‡, to wielkiego znaku zapytania nad gÅ‚owÄ…. SkÄ…d te nawiasy otaczajÄ…ce nazwy naszych zmiennych? Jakim cudem wartoÅ›ci zostajÄ… przypisane do poszczegÃ³lnych pojemnikÃ³w? Gdzie podziaÅ‚a siÄ™ zwrÃ³cona tablica? Przypisanie destrukturyzujÄ…ce to wyraÅ¼enie, ktÃ³re pozwala odpakowaÄ‡ wartoÅ›ci z tabeli lub obiektu do osobnych zmiennych. Jest to moÅ¼liwe poprzez symetryczne odwrÃ³cenie wzorca przypisania. CzÄ™Å›Ä‡ lewostronna jest traktowana jako wzorzec dla dekompozycji wartoÅ›ci z tablicy/obiektu. JeÅ¼eli wzorzec nie zostanie sparowany z wartoÅ›ciÄ…, to zmienna otrzyma wartoÅ›Ä‡ undefined. Obiekt zwracany przez funkcjÄ™ bar nie posiada wÅ‚aÅ›ciwoÅ›ci a, stÄ…d nie zostaÅ‚a do niej przypisana wartoÅ›Ä‡ liczbowa. JeÅ¼eli masz problem z zrozumieniem dziaÅ‚ania funkcji bar, zapraszam do przeczytania mojego wpisu nt. funkcji strzaÅ‚kowych. Okej, jesteÅ›my w stanie odpakowaÄ‡ wartoÅ›ci z obiektu i tablicy, uÅ¼ywajÄ…c przy tym nowej, wypasionej skÅ‚adni. Czy to wszystko, co destrukturyzacja ma do zaoferowania? ",
      "id": 1
    },
    {
      "title": "Destrukturyzacja tablic",
      "text": " Skoro znamy juÅ¼ podstawy skÅ‚adni, moÅ¼emy przejÅ›Ä‡ do ciekawszych sztuczek.\n\nJeÅ¼eli chcemy pominÄ…Ä‡ wybrany element, wstawiamy w jego miejsce przecinek. Pozwala to na selektywne odpakowanie zawartoÅ›Ä‡ zwracanej tablicy.\n\nJeÅ¼eli zaleÅ¼y nam na przypisaniu kilku elementÃ³w i przydzieleniu pozostaÅ‚ej czÄ™Å›ci tablicy do osobnych zmiennych, wystarczy uÅ¼yÄ‡ rest operatora.\n\nJeÅ¼eli operator nie bÄ™dzie w stanie odnaleÅºÄ‡ Å¼adnej wartoÅ›ci do przypisania, zmienna zostanie pustÄ… tablicÄ….\n\nTak siÄ™ skÅ‚ada, Å¼e destrukturyzacja tablic wykorzystuje iterator, aby dostaÄ‡ siÄ™ do wartoÅ›ci ÅºrÃ³dÅ‚owej. DziÄ™ki temu, moÅ¼emy uÅ¼yÄ‡ tej skÅ‚adni dla kaÅ¼dej iterowalnej wartoÅ›ci. Poza tablicami, zaliczamy do nich: Å‚aÅ„cuchy, mapy, zbiory oraz struktury zwracane przez operacje nad DOM.\n\nNieudana destrukturyzacja tablicy\n\nJeÅ¼eli wykorzystujemy skÅ‚adniÄ™ tablicowÄ… const [a, b], to przy prÃ³bie przypisania z ÅºrÃ³dÅ‚a, ktÃ³re nie jest iterowalne, silnik wyrzuca TypeError.\n\nJeÅ¼eli nie mamy stuprocentowej pewnoÅ›ci co do przetwarzanych przez destrukturyzacjÄ™ wartoÅ›ci (np. funkcje asynchroniczne), naleÅ¼y zachowaÄ‡ szczegÃ³lnÄ… ostroÅ¼noÅ›Ä‡. ",
      "id": 2
    },
    {
      "title": "Destrukturyzacja obiektÃ³w",
      "text": " Nic nie stoi na przeszkodzie, aby nazwa zadeklarowanych zmiennych rÃ³Å¼niÅ‚a siÄ™ od nazw wÅ‚aÅ›ciwoÅ›ci obiektu, ktÃ³ry poddajemy destrukturyzacji. Jednak, wiÄ…Å¼e siÄ™ to z zastosowaniem skÅ‚adni, ktÃ³ra poczÄ…tkowo moÅ¼e wydawaÄ‡ siÄ™ pokrÄ™tna.\n\nÅšwiat staje na gÅ‚owie, wszystko na odwrÃ³t. Jak widaÄ‡, po lewej stronie mamy do czynienia z wzorcem ÅºrÃ³dÅ‚o -> cel. Tradycyjne przypisanie korzysta z wzorca cel <- ÅºrÃ³dÅ‚o. Bez paniki, jak to w programowaniu bywa, po przerobieniu kilku przykÅ‚adÃ³w, wszystko zaskoczy na swoje miejsce.\n\nDestrukturyzacja pozwala na wykorzystanie obliczanych kluczy wÅ‚asciwoÅ›ci. Chodzi tutaj o nazwy wÅ‚aÅ›ciwoÅ›ci obliczane z wartoÅ›ci zmiennej, co umoÅ¼liwia notacja nawiasowa [].\n\nNieudana destrukturyzacja obiektu\n\nPodobnie jak w przypadku tablic, musimy uwaÅ¼aÄ‡ na konwersjÄ™ wartoÅ›ci prymitywnych. WiÄ™kszoÅ›Ä‡ z nas jest przyzwyczajona do mechaniki metody Object(). Opakowuje ona wartoÅ›Ä‡ prymitywnÄ… w odpowiedni obiekt.\n\nPolityka wobec null i undefined jest bardzo liberalna. Sytuacja wyglÄ…da inaczej w przypadku metody ToObject(), ktÃ³ra jest wykorzystywana za kulisami podczas destrukturyzacji.\n\nDodatkowo, jeÅ¼eli rozpoczniemy naszÄ… instrukcjÄ™ od klamer, silnik zinterpretuje je jako wyznaczenie granic bloku. ChcÄ…c wykorzystaÄ‡ destrukturyzacjÄ™, warto trzymaÄ‡ siÄ™ inicjalizacji zmiennych. JeÅ¼eli zaleÅ¼y nam na przypisaniu, moÅ¼emy wykorzystaÄ‡ obejÅ›cie z nawiasami. ",
      "id": 3
    },
    {
      "title": "Funkcje strzaÅ‚kowe",
      "text": "Analiza skÅ‚adni\n\nDefinicja funkcji strzaÅ‚kowej skÅ‚ada siÄ™ z listy parametrÃ³w, nastÄ™pujÄ…cego po niej markera => oraz ciaÅ‚a funkcji.\n\nNietrudno zauwaÅ¼yÄ‡, Å¼e w przypadku funkcji z jednym parametrem, nie pojawiÅ‚y siÄ™ przy nim nawiasy otaczajÄ…ce. Jest to jedno z udogodnieÅ„ skÅ‚adniowych. Jednak, obowiÄ…zuje ono tylko, jeÅ¼eli parametr jest pojedynczym identyfikatorem. CÃ³Å¼ to oznacza w praktyce? Ano, jeÅ¼eli chcemy skorzystaÄ‡ z destrukturyzacji lub wartoÅ›ci domyÅ›lnej parametru, to musimy otoczyÄ‡ go nawiasami.\n\nPrzejdÅºmy do kolejnej zasadniczej rÃ³Å¼nicy, dzielÄ…cej funkcje strzaÅ‚kowe od klasycznych deklaracji funkcji i wyraÅ¼eÅ„ funkcyjnych. Jak widaÄ‡ w powyÅ¼szych przykÅ‚adach, oprÃ³cz wspomnianego nawiasu, pozbyliÅ›my siÄ™ rÃ³wnieÅ¼ klamer oraz sÅ‚owa kluczowego return. Klamry moÅ¼na pominÄ…Ä‡ w definicjach, ktÃ³rych ciaÅ‚o zajmuje jednÄ… linijkÄ™. KoniecznoÅ›Ä‡ jawnego uÅ¼ycia return jest zaleÅ¼na od zastosowania klamer.\n\nIm mniej linijek kodu, tym mniejsza szansa na wystÄ…pienie bÅ‚Ä™du. To jedna z najczÄ™Å›ciej wygÅ‚aszanych opinii przez miÅ‚oÅ›nikÃ³w czystego kodu. To niewÄ…tpliwie jeden z gÅ‚Ã³wnych powodÃ³w fenomenu funkcji strzaÅ‚kowych. W wiÄ™kszoÅ›ci przypadkÃ³w pozwalajÄ… zrobiÄ‡ tyle samo, piszÄ…c znacznie mniej. SprawdÅºmy to na przykÅ‚adzie. Powiedzmy, Å¼e chcemy podnieÅ›Ä‡ do kwadratu wszystkie elementy tablicy, ktÃ³re sÄ… parzyste (everyday struggle).\n\nNie uwzglÄ™dniajÄ…c pustych linii, pierwsze rozwiÄ…zanie zajmuje ich 7, podczas gdy drugie zaledwie 3. Ponadto funkcje strzaÅ‚kowe, w przypadku prostych wyraÅ¼eÅ„, sÄ… duÅ¼o bardziej czytelne. MoÅ¼emy skupiÄ‡ peÅ‚niÄ™ naszej uwagi na operacjach jakie wykonujemy, zamiast przedzieraÄ‡ siÄ™ wzrokiem przez niepotrzebne klamry i sÅ‚owa kluczowe.\n\nZobaczmy, jak sprawy siÄ™ majÄ… w przypadku czegoÅ› bardziej wyszukanego. WeÅºmy na warsztat funkcjÄ™ wykorzystujÄ…cej domkniÄ™cia. Skorzystamy tutaj z klasycznego przykÅ‚adu hodowania funkcji dodajÄ…cej wybranÄ… wartoÅ›Ä‡ do dowolnej liczby.\n\nPo raz kolejny funkcja strzaÅ‚kowa wyszÅ‚a zwyciÄ™sko z pojedynku z poczciwÄ… deklaracjÄ…. Jednak, nie zawsze ta zwiÄ™zÅ‚oÅ›Ä‡ skÅ‚adniowa dziaÅ‚a na naszÄ… korzyÅ›Ä‡. Przy bardziej skomplikowanych funkcjach warto rozwaÅ¼yÄ‡, ktÃ³ry wariant jest bardziej zrozumiaÅ‚y i czytelny.\n\nWystarczy zachwytÃ³w zwiÄ…zanych ze skÅ‚adniÄ… funkcji strzaÅ‚kowych. Na koniec wypadaÅ‚oby wspomnieÄ‡ o kilku szczegÃ³Å‚ach, na ktÃ³re warto uwaÅ¼aÄ‡.\n\nMarker => musi znaleÅºÄ‡ siÄ™ w tej samej linijce co lista parametrÃ³w, w innym przypadku silnik wyrzuci SyntaxError.\n\nJeÅ¼eli ciaÅ‚o naszej funkcji zawiera instrukcjÄ™, niezaleÅ¼nie od iloÅ›ci linijek kodu, musimy jÄ… otoczyÄ‡ klamrami.\n\nDrugim specyficznym przypadkiem, jest funkcja zwracajÄ…ca literaÅ‚ obiektowy. Aby wszystko poszÅ‚o zgodnie z planem, musimy otoczyÄ‡ go nawiasami. W tej sytuacji, zostanÄ… one interpretowane jako operator grupujÄ…cy dla zwracanego wyraÅ¼enia. Pozwala to wykorzystaÄ‡ omÃ³wiony wczeÅ›niej mechanizm niejawnego return. W przypadku pominiÄ™cia nawiasÃ³w, klucze naszego obiektu zostanÄ… zainterpretowane jako etykiety, a wartoÅ›ci jako zwykÅ‚e Å‚aÅ„cuchy.\n\nLeksykalne this\n\nPewnie zastanawiacie siÄ™, skÄ…d tyle zachodu z powodu zmiany, ktÃ³ra jedynie wpÅ‚ywa na aspekt wizualny naszego kodu. CaÅ‚e szczÄ™Å›cie, gÅ‚Ã³wny bohater dzisiejszego wpisu niesie ze sobÄ… duÅ¼o istotniejszÄ… zmianÄ™. Komitet TC39 uczyniÅ‚ z funkcji strzaÅ‚kowych remedium na codzienne cierpienia programistÃ³w, ktÃ³rzy mieli doÅ›Ä‡ wywoÅ‚ywania swoich funkcji z dopiskiem .bind(this) oraz korzystania z takich wytrychÃ³w jak var self = this.\n\nTradycyjne funkcje posiadajÄ… dynamiczne wiÄ…zanie this. W duÅ¼ym skrÃ³cie, oznacza to, Å¼e wartoÅ›Ä‡ this jest zaleÅ¼na od kontekstu wywoÅ‚ania funkcji (temat rozwinÄ™ w nadchodzÄ…cym wpisie o tym wskaÅºniku). Taki mechanizm powoduje wiele utrudnieÅ„. ZwÅ‚aszcza gdy z jakiegoÅ› powodu chcemy utworzyÄ‡ obiekt dodajÄ…cy wybranÄ… wartoÅ›Ä‡, gdzie tylko jÄ™zyk pozwoli (everyday struggle part 2).\n\nNiestety, z takim kodem, nasz ambitny plan spali na panewce. W strict modecode>, wskaÅºnik this wewnÄ…trz metody map przyjmie wartoÅ›Ä‡ undefined. Z pominiÄ™ciem strict mode, odwoÅ‚a siÄ™ on do obiektu globalnego Windowcode>. W tym przypadku, nasza funkcja wypluje z siebie [NaN, NaN], a my zaczniemy siÄ™ zastanawiaÄ‡, czy programowanie w JSie, aby na pewno byÅ‚o dobrym pomysÅ‚em.\n\nOczywiÅ›cie, programiÅ›ci tworzÄ… Addery na caÅ‚ym Å›wiecie. Geniusze na miarÄ™ Richarda Hendricksa szybko zorientowali siÄ™, Å¼e jest sposÃ³b na poprawne powiÄ™kszenie elementÃ³w wybranej tablicy o ich ulubionÄ… wartoÅ›Ä‡. Wystarczy skorzystaÄ‡ jeden z wczeÅ›niej wspomnianych wspomagaczy.\n\nZasadniczym minusem tych rozwiÄ…zaÅ„, zwÅ‚aszcza jeÅ¼eli nasza partnerka jest programistkÄ…, jest utrata elegancji naszego kodu. Kilka takich funkcji i usÅ‚yszymy, Å¼e nie robimy tego tak dobrze jak kiedyÅ›. Mimo Å¼e nie mam takiego problemu, to dbam o los kolegÃ³w z branÅ¼y. Mam do zaoferowania znacznie lepsze rozwiÄ…zanie.\n\nWskaÅºnik this przyjmuje wartoÅ›Ä‡ zgodnÄ… z oczekiwaniami, poniewaÅ¼ funkcje strzaÅ‚kowe posiadajÄ… zakres leksykalny. Jak dziaÅ‚a zakres leksykalny? Po raz kolejny, w duÅ¼ym skrÃ³cie, jeÅ¼eli identyfikator nie zostanie odnaleziony w aktywnym zakresie, jest on wyszukiwany w zakresie otaczajÄ…cym.",
      "id": 4
    },
    {
      "title": "Kiedy NIE uÅ¼ywaÄ‡ funkcji strzaÅ‚kowych",
      "text": "Zanim odjedziemy do stacji strzaÅ‚kowego hypeâ€™u, warto zastanowiÄ‡ siÄ™, czy faktycznie mamy do czynienia z rozwiÄ…zaniem niezawodnym. CzyÅ¼by sÅ‚owo kluczowe function wybieraÅ‚o siÄ™ na emeryturÄ™? Spoiler alert: nic bardziej mylnego.\nKonstruktory\n\nWracajÄ…c do naszego Addera, moglibyÅ›my pokusiÄ‡ siÄ™ o przepisanie funkcji konstruujÄ…cej z uÅ¼yciem strzaÅ‚ki.\n\nCzybyÅ¼by funkcje strzaÅ‚kowe byÅ‚y wybrakowane w stosunku do swoich poprzednikÃ³w? Na to wyglÄ…da. ZwykÅ‚e funkcje obsÅ‚ugujÄ… new za pomocÄ… wewnÄ™trznej metody [[Construct]] oraz wÅ‚aÅ›ciwoÅ›ci prototype. Funkcje strzaÅ‚kowe nie posiadajÄ… Å¼adnej z nich, stÄ…d zaobserwowany bÅ‚Ä…d.\nMetody\n\nKolejny psikus czeka nas w przypadku metod. W tym przypadku, dokÅ‚adnie ten sam mechanizm, ktÃ³ry zmuszaÅ‚ nas do stosowania .bind(this), jest nam na rÄ™kÄ™.\n\nWskaÅºnik this w metodzie getLikes() wskazuje na obiekt globalny Window. Jest to spowodowane brakiem utworzenia wÅ‚asnego wiÄ…zania this i wyszukiwaniem w zakresie leksykalnym. Nic straconego, sukces na social-media i tak mam zagwarantowany. Funkcja ustawiajÄ…ca iloÅ›Ä‡ lajkÃ³w dziaÅ‚a jak naleÅ¼y ;).\nObsÅ‚uga zdarzeÅ„\n\nAnalogicznie do metod, sytuacja powtarza siÄ™ przy nasÅ‚uchiwaniu zdarzeÅ„ na elementach DOM.\n\nFunkcje wykorzystujÄ…ce obiekt arguments\n\nTablico-podobny obiekt arguments przechowuje wszystkie argumenty przekazane do zadeklarowanej funkcji lub wyraÅ¼enia funkcyjnego. Niestety, na prÃ³Å¼no szukaÄ‡ go wewnÄ…trz funkcji strzaÅ‚kowej. Funkcje strzaÅ‚kowe nie wiÄ…Å¼Ä… wÅ‚asnego this, arguments, super oraz new.target. JeÅ¼eli chcemy w naszej funkcji strzaÅ‚kowej odwoÅ‚ywaÄ‡ siÄ™ do wszystkich przekazanych argumentÃ³w, musimy skorzystaÄ‡ z spread operatora.\nJak Å¼yÄ‡?\n\nMiaÅ‚o byÄ‡ tak piÄ™knie, wyszÅ‚o jak zwykle. BiorÄ…c pod uwagÄ™ wymienione wyjÄ…tki, kiedy moÅ¼na ze spokojem korzystaÄ‡ z funkcji strzaÅ‚kowych? ProponujÄ™ tutaj podejÅ›cie zaproponowane przez Larsa SchÃ¶ninga na stackoverflow:\n\n    Wykorzystuj function w zakresie globalnym oraz dla wÅ‚aÅ›ciwoÅ›ci Object.prototype.\n    Wykorzystuj class dla konstruktorÃ³w obiektÃ³w.\n    Wykorzystuj => w kaÅ¼dym innym przypadku.\n\nJeÅ¼eli takie podejÅ›cie do Ciebie nie przemawia, moÅ¼esz zawsze skorzystaÄ‡ z niezawodnego, lecz w moich oczach karykaturalnego wykresu, zaproponowanego przez Kyleâ€™a Simposona.",
      "id": 5
    },
    {
      "title": "Prototypy i dziedziczenie",
      "text": "Dziedziczenie klasowe\n\nPostrzegajÄ…c ten problem przez pryzmat jÄ™zykÃ³w obiektowych zorientowanych na klasy, zanim przejdziemy do wytwarzania, musimy przygotowaÄ‡ specyfikacjÄ™ produktu.\nRolÄ™ specyfikacji bÄ™dzie stanowiÅ‚a klasa KrzesÅ‚o. ZamieÅ›cimy w niej wszystkie wÅ‚aÅ›ciwoÅ›ci i funkcjonalnoÅ›ci krzeseÅ‚, ktÃ³re bÄ™dziemy produkowaÄ‡. Najpierw skupimy siÄ™ na najprostszym modelu, jaki przychodzi nam do gÅ‚owy, zostawiajÄ…c sobie furtkÄ™ do dalszych usprawnieÅ„ w przyszÅ‚oÅ›ci.\n\nMajÄ…c do dyspozycji taki plan, wystarczy wydzieliÄ‡ odpowiedniÄ… iloÅ›Ä‡ zasobÃ³w i moÅ¼emy zabieraÄ‡ siÄ™ do pracy. Wychodzimy z zaÅ‚oÅ¼enia, Å¼e kaÅ¼dy egzemplarz powinien byÄ‡ idealnym odzwierciedleniem przygotowanej specyfikacji. StÄ…d, mÃ³wi siÄ™, Å¼e wyprodukowane przez nas krzesÅ‚a sÄ… instancjami klasy KrzesÅ‚o.\n\nJeÅ¼eli chcielibyÅ›my stworzyÄ‡ nowy model krzesÅ‚a, nie musimy traciÄ‡ czasu na tworzenie zupeÅ‚nie nowej specyfikacji. KrzesÅ‚a dzielÄ… ze sobÄ… wiele cech charakterystycznych, niezaleÅ¼nie od rÃ³Å¼nic w szczegÃ³Å‚ach. KaÅ¼de z nich bÄ™dzie miaÅ‚o cztery nogi, siedzenie i oparcie, a jego gÅ‚Ã³wnym przeznaczeniem bÄ™dzie moÅ¼liwoÅ›Ä‡ zajÄ™cia na nim miejsca. Wszystkie te cechy sÄ… opisane w naszej klasie KrzesÅ‚o.\n\nMoÅ¼emy uznaÄ‡ nasz pierwotny projekt za punkt wyjÅ›cia. Wystarczy go skopiowaÄ‡, nanieÅ›Ä‡ na niego innowacyjne zmiany, i voila â€“ mamy do dyspozycji nowy produkt. Taki proces nazywamy dziedziczeniem klasowym.\nDziedziczenie prototypowe\n\nJeÅ¼eli zdecydujemy siÄ™ na podejÅ›cie prototypowe, zabierzemy siÄ™ za ten problem zupeÅ‚nie inaczej. Wychodzimy z zaÅ‚oÅ¼enia, Å¼e proces produkcji pierwszego egzemplarza dostarczy nam know-how, ktÃ³re pozwoli na sprawnÄ… produkcjÄ™ kolejnych. Nie bÄ™dziemy traciÄ‡ czasu na tworzenie specyfikacji. Bierzemy materiaÅ‚y, instrukcjÄ™ z IKEA (lub zaprzyjaÅºnionego bloga programistycznego) i po chwili jesteÅ›my posiadaczami prototypu krzesÅ‚a.\n\nTo krzesÅ‚o, konkretny obiekt, bÄ™dzie stanowiÅ‚o wzÃ³r dla wszystkich nastÄ™pnych krzeseÅ‚.\nTakie nastawienie, ignorujÄ…ce rygor przestrzegania specyfikacji, daje nam moÅ¼liwoÅ›Ä‡ pÃ³Åºniejszego nanoszenia modyfikacji. TworzÄ…c kolejne krzesÅ‚a, interesujÄ… nas tylko nowoÅ›ci w stosunku do prototypu. W razie wÄ…tpliwoÅ›ci co do wÅ‚asnoÅ›ci produktu, wystarczy zerknÄ…Ä‡ na jego prototyp. Takie odwoÅ‚ywanie siÄ™ do prototypÃ³w, wskazywanie ich za pomocÄ… referencji, nazywamy Å‚aÅ„cuchem prototypowym. Wykorzystywanie wÅ‚asnoÅ›ci prototypu nazywamy dziedziczeniem prototypowym.\n\nWarto wiedzieÄ‡: SÅ‚owo kluczowe class pojawiÅ‚o siÄ™ w skÅ‚adni jÄ™zyka dopiero za sprawÄ… ES6. Jest to jedynie upiÄ™kszenie skÅ‚adni, ktÃ³re w ostatecznoÅ›ci sprowadza siÄ™ do wykorzystywania prototypÃ³w.\nPrototypy w JS\n\nKaÅ¼dy obiekt w momencie utworzenia otrzymuje ukrytÄ… wÅ‚aÅ›ciwoÅ›Ä‡ [[Prototype]]. MoÅ¼e ona przyjÄ…Ä‡ dwie wartoÅ›ci: null\nlub referencjÄ™ do obiektu nazywanego prototypem. JeÅ¼eli sprÃ³bujemy odwoÅ‚aÄ‡ siÄ™ do wÅ‚aÅ›ciwoÅ›ci, ktÃ³ra nie zostanie odnaleziona w obiekcie, silnik bÄ™dzie kontynuowaÅ‚ poszukiwania, w obiekcie wskazywanym przez [[Prototype]].\nJeÅ¼eli wÅ‚aÅ›ciwoÅ›Ä‡ zostanie odnaleziona w prototypie, silnik zwrÃ³ci przypisanÄ… do niej wartoÅ›Ä‡, tak jakby znajdowaÅ‚a siÄ™ w naszym obiekcie od samego poczÄ…tku.\n\nPodczas swoich poszukiwaÅ„ silnik nie zatrzymuje siÄ™ na bezpoÅ›rednim prototypie naszego obiektu. Przemierzy on caÅ‚y Å‚aÅ„cuch prototypÃ³w. BÄ™dzie szukaÅ‚ w prototypie prototypu etc., aÅ¼ do momentu natrafienia na [[Prototype]] z wartoÅ›ciÄ… null.\nDomyÅ›lnie ostatnim ogniwem Å‚aÅ„cucha prototypÃ³w jest Object.prototype. JeÅ¼eli wyszukiwana wÅ‚aÅ›ciwoÅ›Ä‡ nie zostanie odnalezionaw w Å¼adnym z przeszukiwanych obiektÃ³w, to silnik uraczy nas wartoÅ›ciÄ… undefined.\n\nJak w przypadku wszystkich ukrytych wÅ‚aÅ›ciwoÅ›ci, nie mamy moÅ¼liwoÅ›ci bezpoÅ›redniej interakcji z [[Prototype]].\nJako interfejs sÅ‚uÅ¼Ä… nam metody obiektu globalnego Object.\nObject.getPrototypeOf(obj) zwraca referencjÄ™ do [[Prototype]], podczas gdy Object.setProtytypeOf(obj, proto) pozwala ustawiÄ‡ prototyp obj na obiekt proto.\n\nJeÅ¼eli chcemy ustawiÄ‡ prototyp obiektu w momencie jego inicjalizacji, naleÅ¼y wykorzystaÄ‡ Object.create(proto, objectProperties). Ta metoda zwrÃ³ci nam nowy obiekt z wÅ‚aÅ›ciwoÅ›ciÄ… [[Prototype]] wskazujÄ…cÄ… na proto.\n\nCzasami zaleÅ¼y nam na sprawdzeniu, czy obiekt posiada swojÄ… prywatnÄ… wÅ‚aÅ›ciwoÅ›Ä‡, czy uzyskuje do niej dostÄ™p z\nÅ‚aÅ„cucha prototypÃ³w. W tym wypadku wykorzystuje siÄ™ metodÄ™ Object.hasOwnProperty(obj, prop).\n\nTyle z suchej teorii, przejdÅºmy do analizy kodu. PrzygotowaÅ‚em dla Was dwie wersje prostego programu generujÄ…cego obiekty graczy NBA. Pierwsza z nich jest zaimplementowana w oparciu o wzorzec dziedziczenia prototypowego. Druga wersja zawiera alternatywny wzorzec, delegacjÄ™ zachowaÅ„.\n\nZanim przejdziemy dalej, upewnij siÄ™, Å¼e rozumiesz, jak dziaÅ‚a wskaÅºnik this w JS. Dodam tylko, Å¼e prototypy nie majÄ… Å¼adnego wpÅ‚ywu na wartoÅ›Ä‡ tego wskaÅºnika.\n",
      "id": 6
    },
    {
      "title": "WskaÅºnik this w JavaScript",
      "text": "W JavaScript wiÄ…zanie this jest zaleÅ¼ne od kontekstu wywoÅ‚ania funkcji. WyrÃ³Å¼nia siÄ™ piÄ™Ä‡ takich kontekstÃ³w: domyÅ›lny, niejawny, jawny, twardy, konstrukcyjny. OczywiÅ›cie moÅ¼e dojÅ›Ä‡ do konfliktu kilku kontekstÃ³w, stÄ…d musimy znaÄ‡ ich hierarchiÄ™. To nie wszystko, tryb restrykcyjny (strict mode) rÃ³wnieÅ¼ ma istotny wpÅ‚yw na dziaÅ‚anie wskaÅºnika this.\n\nJak widaÄ‡, mamy do czynienia z nie lada szataÅ„stwem. Nie pozostaÅ‚o nam nic innego jak zarzuciÄ‡ na nie Å‚aÅ„cuchy doÅ›wiadczenia i zaciÄ…gnÄ…Ä‡ do pracy w naszym kodzie. Bez zrozumienia wszystkich wspomnianych mechanizmÃ³w nie bÄ™dziemy w stanie poczyniÄ‡ postÄ™pÃ³w w programowaniu obiektowym. this to absolutny fundament tego paradygmatu. Pozwala na zrezygnowanie z jawnego odwoÅ‚ywania siÄ™ do obiektu. StÄ…d juÅ¼ krÃ³tka droga do wszechstronnych funkcji, ktÃ³re, bez dodatkowych modyfikacji, bÄ™dÄ… sobie radziÅ‚y z rÃ³Å¼nymi parametrami.\n\nEfektywna praca z this w JavaScript wymaga znajomoÅ›ci trzech metod. DziÄ™ki nim moÅ¼emy w jawny sposÃ³b wskazaÄ‡, z jakÄ… wartoÅ›ciÄ… ma byÄ‡ zwiÄ…zane this. Wspomniane metody to: Function.prototype.call, Function.prototype.apply i Function.prototype.bind.\n\nFunction.prototype.call wywoÅ‚uje funkcjÄ™ z wartoÅ›ciÄ… this wskazanÄ… w pierwszym parametrze. ResztÄ™ parametrÃ³w, przekazywanych do wywoÅ‚ywanej funkcji, przyjmuje indywidualnie. Function.prototype.apply, kuzyn call, ma takie samo dziaÅ‚anie na this, ale resztÄ™ parametrÃ³w przyjmuje jako tablicÄ™.\n\nFunction.prototype.bind zwraca nowy egzemplarz funkcji. Przy wywoÅ‚aniu, wiÄ…zanie this bÄ™dzie trwale wskazywaÅ‚o na wartoÅ›Ä‡, przekazanÄ… podczas tworzenia funkcji.",
      "id": 7
    },
    {
      "title": "DomkniÄ™cia ",
      "text": " DomkniÄ™cie to funkcja, ktÃ³ra pamiÄ™ta swoje otoczenie leksykalne i moÅ¼e uzyskaÄ‡ do niego dostÄ™p. W JS kaÅ¼da funkcja jest domkniÄ™ciem, poniewaÅ¼ przechowuje informacje o swoim Å›rodowisku leksykalnym dziÄ™ki ukrytej wÅ‚aÅ›ciwoÅ›ci [[Environment]].\n\nJak ta definicja przekÅ‚ada siÄ™ na pracÄ™ z kodem? JuÅ¼ podczas stawiania pierwszych krokÃ³w z JS, intuicyjnie wykorzystujemy moÅ¼liwoÅ›Ä‡ odwoÅ‚ywania do zmiennych globalnych z poziomu funkcji.\n\nCzy jesteÅ›my tego Å›wiadomi czy nie, najprostsze domkniÄ™cia towarzyszÄ… nam od samych poczÄ…tkÃ³w programowania. To wÅ‚aÅ›nie funkcja poÅ‚Ä…czona z moÅ¼liwoÅ›ciÄ… odwoÅ‚ywania siÄ™ do zakresÃ³w zewnÄ™trznych stanowi istotÄ™ domkniÄ™cia. MoÅ¼na powiedzieÄ‡, Å¼e funkcja domyka siÄ™ na zakresie otaczajÄ…cym podczas wyszukiwania zmiennej.\n\nAby taka mechanika miaÅ‚a rÄ™ce i nogi, silnik zamraÅ¼a zakres funkcji otaczajÄ…cej, nawet jeÅ¼eli minÄ™Å‚o duÅ¼o czasu od jej wykonywania. Stan zmiennych jest przechowywany w pamiÄ™ci, dopÃ³ki istnieje funkcja, ktÃ³ra domyka siÄ™ na tym zakresie.\n\nNajÅ‚atwiejszym sposobem doprowadzenia do takiej sytuacji jest zwrÃ³cenie przez funkcjÄ™ otaczajÄ…cÄ… nowej funkcji lub obiektu z referencjÄ… do funkcji zagnieÅ¼dÅ¼onej. Pozwala to na tworzenie moduÅ‚Ã³w wykorzystujÄ…cych hermetyzacjÄ™ danych. Mamy peÅ‚nÄ… kontrolÄ™ nad interfejsem naszego kodu. ",
      "id": 8
    },
    {
      "title": "Var vs Let vs Const ",
      "text": "Hoisting\n\nZmienne w JavaScript podlegajÄ… zjawisku o nazwie podnoszenia czy windowania (ang. hoisting). Co to w ogÃ³le oznacza? NajproÅ›ciej wytÅ‚umaczyÄ‡ to tak, Å¼e JavaScript przenosi deklaracje zmiennych zainicjowanych na poczÄ…tek funkcji.\n\nZerknijmy na nastÄ™pujÄ…cy przykÅ‚ad:\n\nKonsola wyÅ›wietli wynik 5, chociaÅ¼ najpierw przypisaliÅ›my wartoÅ›Ä‡ do zmiennej,\na dopiero pÃ³Åºniej jÄ… zadeklarowaliÅ›my.\n\nWindowaniu podlegajÄ… tylko deklaracje, a nie przypisanie wartoÅ›ci do zmiennych.\n\nWarto podkreÅ›liÄ‡, Å¼e zmienne deklarowane za pomocÄ… â€varâ€ czy â€functionâ€ sÄ… inicjalizowane od razu i przypisanÄ… majÄ… wartoÅ›Ä‡ undefined. Za to zmienne â€letâ€\nczy â€constâ€ sÄ… inicjalizowane podczas definicji zmiennej. DokÅ‚adnie wyjaÅ›nia to poniÅ¼szy przykÅ‚ad:\nZmienna o zasiÄ™gu blokowym\n\nJeÅ›li chcemy mieÄ‡ zmienne o zasiÄ™gu blokowym, to mamy do wyboru dwa typy: â€letâ€\noraz â€constâ€. Dla wielu programistÃ³w jest to rozwiÄ…zanie bliÅ¼sze â€sercuâ€, niÅ¼ zmienna\no zasiÄ™gu funkcyjnym.\n\nâ€letâ€, w skrÃ³cie, to blokowy odpowiednik â€varâ€.\n\nâ€constâ€ za to reprezentuje staÅ‚Ä…. Podczas deklaracji zmiennej musimy od razu przypisaÄ‡ jej wartoÅ›Ä‡, ktÃ³rej pÃ³Åºniej nie moÅ¼na zmieniÄ‡.\nDziaÅ‚anie\n\nW podanym przykÅ‚adzie, programu zmienia swoje zachowanie w porÃ³wnaniu do wersji z â€varâ€. W kaÅ¼dym bloku deklarujemy nowÄ… zmiennÄ… x, jednak nie nadpisuje ona wartoÅ›ci zmiennej o tej nazwie, zdefiniowanej w bloku â€wyÅ¼ejâ€.\n\nIdentyczna sytuacja bÄ™dzie, gdy sÅ‚owa â€letâ€, zamienimy na â€constâ€.\n\nOczywiÅ›cie moÅ¼emy odwoÅ‚ywaÄ‡ siÄ™ do zmiennych typu â€letâ€ czy â€constâ€ w blokach zagnieÅ¼dÅ¼onych.\n\nNa koniec ostatni przykÅ‚ad z zastosowania â€letâ€ oraz â€varâ€ w jednej funkcji.\n\nZmienna zdefiniowana za pomocÄ… â€letâ€ przyjmuje swojÄ… wartoÅ›Ä‡, tylko w swoim bloku. Nie zakÅ‚Ã³ca przez to dziaÅ‚ania dalszego kodu.\n\nZastanÃ³wmy siÄ™ nad odwrotnÄ… sytuacjÄ…- najpierw definiujemy x jako â€letâ€, a w bloku if jako â€varâ€. Takie dziaÅ‚anie nie bÄ™dzie poprawne. Dlaczego? To juÅ¼ zostawiam do samodzielnego zastanowienia siÄ™ ğŸ™‚\nPodsumowanie\n\nOdpowiednie stosowanie â€varâ€, â€letâ€ oraz â€constâ€ pozwoli nam uniknÄ…Ä‡ wielu bÅ‚Ä™dÃ³w, ktÃ³re sÄ… doÅ›Ä‡ trudne do odnalezienia.",
      "id": 9
    },
    {
      "title": "Obietnice",
      "text": " Czym sÄ… Obietnice?\n\nObietnice to specjalny obiekt. Jak to z obiektami bywa, moÅ¼na je utworzyÄ‡ za pomocÄ… konstruktora. Konstruktor Obietnicy jako parametr przyjmuje funkcjÄ™ o dwÃ³ch argumentach: resolve i reject. Aby speÅ‚niÄ‡ obietnicÄ™, wewnÄ…trz tejÅ¼e funkcji, wywoÅ‚ujemy resolve(value). value to wartoÅ›Ä‡, ktÃ³rÄ… chcemy przekazaÄ‡ do procedury obsÅ‚ugi. JeÅ¼eli chcemy odrzuciÄ‡ obietnicÄ™, to wywoÅ‚ujemy reject(error). Jako error moÅ¼emy przekazaÄ‡ dowolnÄ… wartoÅ›Ä‡ podobnie jak w przypadku resolve. JednakÅ¼e dobrÄ… praktykÄ… jest zwracanie obiektu bÅ‚Ä™du lub chociaÅ¼ wiadomoÅ›ci opisujÄ…cej powÃ³d odrzucenia obietnicy. Przed speÅ‚nieniem lub odrzuceniem, obietnica jest w stanie oczekujÄ…cym.\n\nObietnice majÄ… dwie wewnÄ™trzne wÅ‚aÅ›ciwoÅ›ci: stan i wartoÅ›Ä‡ zwrotnÄ…. Stan Obietnicy poczÄ…tkowo jest ustawiony na â€šoczekujÄ…caâ€™ (pending). W przypadku wywoÅ‚ania resolve(), stan zmienia siÄ™ na â€šwywiÄ…zanaâ€™ (fulfilled). Analogicznie, reject() sprawia, Å¼e mamy do czynienia z â€šodrzuconÄ…â€™ (rejected ObietnicÄ…. WartoÅ›Ä‡ zwrotna to wartoÅ›Ä‡ zwracana przez ObietnicÄ™, czyli argument przekazany do dwÃ³ch wczeÅ›niej wymienionych metod.\n\nJeÅ¼eli wykorzystujemy wewnÄ™trznÄ… metodÄ™ resolve(value), ktÃ³ra oznacza pomyÅ›lne wykonanie zadania, to ustawiamy wÅ‚aÅ›ciwoÅ›ci:\n\n    Stan na â€šwywiÄ…zanaâ€™\n    WartoÅ›c zwrotna na value\n\nJeÅ¼eli wykorzystujemy wewnÄ™trznÄ… metodÄ™ reject(error), ktÃ³ra oznacza wystapienie bÅ‚Ä™du podczas wykonywania zadania, to ustawiamy wÅ‚aÅ›ciwoÅ›ci:\n\n    Stan na â€šodrzuconaâ€™\n    WartoÅ›Ä‡ zwrotna na error\n\nUtworzenie obietnicy to dopiero poczÄ…tek, musimy jÄ… jeszcze wykonaÄ‡. Aby to zrobiÄ‡, wystarczy wywoÅ‚aÄ‡ jÄ… jak kaÅ¼dÄ… funkcjÄ™. W nastÄ™pstwie wywoÅ‚ania obietnicy, otrzymujemy dostep do procedury obsÅ‚ugi .then(). Przyjmuje ona dwa argumenty, kaÅ¼dy z nich to funkcja przechwytujÄ…ca wartoÅ›Ä‡ przekazanÄ… przez ObietnicÄ™. Pierwsza z nich zostanie wywoÅ‚ana w przypadku wywiÄ…zania siÄ™ z obietnicy (zastosowanie resolve()), druga z nich w przypadku bÅ‚Ä™du (zastosowanie reject()).\n\nAby zwiÄ™kszyÄ‡ czytelnoÅ›Ä‡ kodu, moÅ¼emy wykorzystaÄ‡ drugÄ… procedurÄ™ obsÅ‚ugi, .catch. ZastÄ™puje ona drugÄ… funkcjÄ™ przekazywanÄ… do .then() â€“ tÄ™, ktÃ³ra sÅ‚uÅ¼y do przechytywania bÅ‚Ä™du. To follow-up do bloku try/catch.\n\nKod funkcji przekazanej do obietnicy, jest wykonywany automatycznie i natychmiastowo, w momencie utworzenia nowej obietnicy za pomocÄ… konstruktora new Promise.\nWywoÅ‚anie resolve() bÄ…dÅº reject() jest rÃ³wnoznaczne z zastosowaniem sÅ‚owa kluczowego return w normalnej funkcji. Silnik zwraca wartoÅ›Ä‡ i przechodzi do wykonywania kolejnej funkcji ze stosu. StÄ…d nie ma moÅ¼liwoÅ›ci wywiÄ…zania i odrzucenia tej samej Obietnicy.\n\nWarto wiedzieÄ‡: mimo Å¼e moÅ¼emy przekazaÄ‡ do reject jakÄ…kolwiek wartoÅ›Ä‡, to preferowane jest zwracanie obiektÃ³w poÅ‚Ä…czonych prototypowo z Error.\nProcedury obsÅ‚ugi: .then() i catch()\n\nDziaÅ‚anie procedur obsÅ‚ugi Obietnicy Å›wietnie obrazuje poniÅ¼szy przykÅ‚ad. Za jego pomocÄ… moÅ¼emy doÅ‚Ä…czyÄ‡ dowolny skrypt do nagÅ‚Ã³wka strony.\n\nDopÃ³ki Obietnica jest w stanie oczekujÄ…cym, to procedury .then() i .catch() czekajÄ… na wartoÅ›Ä‡ zwrtonÄ…. Po jej przekazaniu, dochodzi do wywoÅ‚ania jednej z procedur.\n\nTak to wyglÄ…da w przypadku kodu asynchronicznego. Nic nie stoi na przeszkodzie, aby Obietnica obsÅ‚ugiwaÅ‚a synchronicznÄ… funkcjÄ™. Tym razem procedury wykonajÄ… siÄ™ natychmiastowo.\n\nTutaj warto zaznaczyÄ‡, Å¼e same funkcje przekazane do .then()/.catch() zawsze sÄ… wykonywane asynchronicznie. TrafiajÄ… one do wewnÄ™trznej kolejki wykonywania funkcji. Silnik JS pobiera kolejne funkcji z kolejki i wykonuje je po zakoÅ„czeniu dziaÅ‚ania obecnie wykonywanego kodu. DziaÅ‚a to na podobnej zasadzie jak setTimeout(â€¦, 0).\n\nJednÄ… z niebywaÅ‚ych zalet obietnic jest moÅ¼liwoÅ›Ä‡ wykorzystywania return â€“ w ten sposÃ³b rezygnujemy z niepoÅ¼Ä…danego wykorzystywania efektÃ³w ubocznych.\n\nCo moÅ¼emy zwrÃ³ciÄ‡ wewnÄ…trz .then()?\n\n    KolejnÄ… ObietnicÄ™\n    WartoÅ›Ä‡ zwrotnÄ…\n    WyrzuciÄ‡ bÅ‚Ä…d za pomocÄ… throw\n\n1. Zwracanie Obietnicy.\n\n2. Zwracanie wartoÅ›ci.\n\nNie jesteÅ›my ograniczeni do zwrÃ³cenia obietnicy, jeÅ¼eli mamy dostÄ™p do danych bez wykonywania zapytania â€“ zrÃ³bmy to.\n\n3. Wyrzucenie bÅ‚Ä™du za pomocÄ… throw.\n\nW ten sposÃ³b moÅ¼emy wyrzuciÄ‡ bÅ‚Ä…d z wartoÅ›ciÄ… synchronicznÄ…. Spowoduje to przechywycenie bÅ‚Ä™du przez metodÄ™ .catch().\n\nÅaÅ„cuchownie Obietnic\n\nWspomniana w wstÄ™pie piramida zagÅ‚ady pojawia siÄ™ w przypadku ciÄ…gÅ‚ego przekazywania wartoÅ›ci zwrotnej jednej funkcji asynchronicznej do kolejnej. W przypadku Obietnic moÅ¼emy utworzyÄ‡ sekwencjÄ™ .then() i .catch() o dowolnej dÅ‚ugoÅ›ci.\n\nJeÅ¼eli obietnica zostanie wykonana, to przechodzimy do kolejnego .then(). W przypadku bÅ‚Ä™du przechodzimy do najbliÅ¼szego .catch().\nPromise.all()\n\nPrzypuÅ›Ä‡my, Å¼e zaleÅ¼y nam na wywoÅ‚aniu kilku Obietnic, jedna po drugiej. Nastepnie chcemy przeanalizowaÄ‡ czy wszystko poszÅ‚o zgodnie z planem. Najbardziej intuicyjnym rozwiÄ…zaniem byÅ‚oby obsÅ‚uÅ¼enie wartoÅ›ci przechowywanych w tablicy za pomocÄ… forEach.\n\nW takiej sytuacji nasza funkcja zwraca undefined. GdybyÅ›my dodali return w forEach, nic by siÄ™ nie zmieniÅ‚o. Kod wewnÄ…trz forEach to zwykÅ‚y callback, ma swÃ³j wÅ‚asny zakres.\n\nCo nas interesuje to return Promise.all(). W ten sposÃ³b zgodnie z oczekiwaniami zareagujemy na wywiÄ…zanie/zerwanie wszystkich obietnic.\n\nJeÅ¼eli chcemy jednoczeÅ›nie wykonaÄ‡ kilka obietnic i zareagowaÄ‡ na to czy wszystkie zostaÅ‚y wykonane, to powinniÅ›my posÅ‚uÅ¼yÄ‡ siÄ™ Promise.all(). Metoda ta zwraca ObietnicÄ™ tylko jeÅ¼eli wszystkie Obietnice przekazane w parametrze (jako tablica, stÄ…d zastosowanie .map() zamiast .forEach()) zostaÅ‚y wywiÄ…zane. JeÅ¼eli jakakolwiek z Obietnic zostanie odrzuca, wywoÅ‚a siÄ™ procedura .catch().\nNa co uwaÅ¼aÄ‡ stosujÄ…c Obietnice?\n\nObietnice sÄ… czymÅ› co ma uchroniÄ‡ nas od callbackowego piekÅ‚a, a nie sÅ‚uÅ¼yÄ‡ za nakÅ‚adkÄ™ skÅ‚adniowÄ…, z ktÃ³rej nie wynika Å¼adna poprawa w czytelnoÅ›ci kodu.\n\nAby ustrzec siÄ™ przed takim kodem, stosujmy Å‚aÅ„cuchowanie i kompozycjÄ™ Obietnic.\n\nWarto pamiÄ™taÄ‡ o umieszczaniu chociaÅ¼by jednej procedury .catch(). Bez tej metody nie doÅ›Ä‡, Å¼e nie przechwycimy Å¼adnego bÅ‚Ä™du, to na dodatek nie bÄ™dziemy Å›wiadomi ich wystÄ…pienia â€“ nie wyswietlÄ… siÄ™ nawet w konsoli.\nCallbacki vs Obietnice â€“ porÃ³wnanie.\n\nOkej, skoro udaÅ‚o nam siÄ™ rozbudowaÄ‡ wiedzÄ™ o Obietnicach to sensownym podsumowaniem byÅ‚oby porÃ³wnanie czym tak naprawdÄ™ rÃ³Å¼niÄ… siÄ™ od callbackÃ³w.\n\nCallbacki:\nMusimy mieÄ‡ gotowy callback w momencie wywoÅ‚ywania kodu asynchronicznego. Innymi sÅ‚owy, musimy wiedzieÄ‡ co zrobiÄ‡ z wynikami przed przystÄ…pieniem do dziaÅ‚ania.\nNasz kod asynchroniczny moÅ¼e obsÅ‚ugiwaÄ‡ tylko jeden callback.\n\nObietnice:\nObietnice pozwalajÄ… na kodowanie czynnoÅ›ci w naturalnym porzadku. Pierw wywoÅ‚ujemy funkcjÄ™ wykonujÄ…cÄ… zapytanie. NastÄ™pnie, rezultatem zajmujemy siÄ™ wewnÄ…trz procedur obsÅ‚ugi .then() i catch(). MoÅ¼emy wywoÅ‚aÄ‡ .then() na jednej obietnicy ile razy chcemy â€“ taki zabieg nazywamy Å‚aÅ„cuchowaniem Obietnic. JeÅ¼eli zaleÅ¼y nam na zbiorczej obsÅ‚udze kilku zapytaÅ„, moÅ¼emy wykorzystaÄ‡ Promise.all().\nPodsumowanie\n\nTyle na temat Obietnic. UdaÅ‚o nam siÄ™ przerobiÄ‡ kolejny naprawdÄ™ istotny element ES6. PoczÄ…tkowo wydawaÅ‚o mi siÄ™, Å¼e temat jest naprawdÄ™ skomplikowany i trudno byÅ‚o mi siÄ™ w tym wszystkim poÅ‚apaÄ‡. Mam nadziejÄ™, Å¼e Wy nie macie takiego wraÅ¼enia po przeczytaniu tego wpisu.\n\nZachÄ™cam do Å›ledzenia bloga na facebooku. Zapraszam do wspÃ³lnego Ä‡wierkania na Twitterze.\n\nW przyszÅ‚ym tygodniu ostatni (!) wpis omawiajÄ…cy nowinki z ES6, tym razem zajmiemy siÄ™ moduÅ‚ami. ",
      "id": 10
    }
  ]
}