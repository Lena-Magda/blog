{
  "posts": [
    {
      "title": "Destrukturyzacja",
      "text": " Jak trafnie stwierdził Kyle Simpson w książce ECMAScript 6 i dalej, manualne przypisanie indeksowanej wartości z tablicy lub właściwości z obiektu można nazwać przypisaniem strukturalnym. Okej, ale co to ma wspólnego z tą tajemniczą destrukturyzacją. Podążając za wywodem Kyle’a, możemy spodziewać się operacji o odwrotnym działaniu do zaprezentowanej w powyższym przykładzie. Zobaczmy, jak to wygląda w praktyce. Przy pierwszym kontakcie z taką składnią, jedyne, czego można oczekiwać, to wielkiego znaku zapytania nad głową. Skąd te nawiasy otaczające nazwy naszych zmiennych? Jakim cudem wartości zostają przypisane do poszczególnych pojemników? Gdzie podziała się zwrócona tablica? Przypisanie destrukturyzujące to wyrażenie, które pozwala odpakować wartości z tabeli lub obiektu do osobnych zmiennych. Jest to możliwe poprzez symetryczne odwrócenie wzorca przypisania. Część lewostronna jest traktowana jako wzorzec dla dekompozycji wartości z tablicy/obiektu. Jeżeli wzorzec nie zostanie sparowany z wartością, to zmienna otrzyma wartość undefined. Obiekt zwracany przez funkcję bar nie posiada właściwości a, stąd nie została do niej przypisana wartość liczbowa. Jeżeli masz problem z zrozumieniem działania funkcji bar, zapraszam do przeczytania mojego wpisu nt. funkcji strzałkowych. Okej, jesteśmy w stanie odpakować wartości z obiektu i tablicy, używając przy tym nowej, wypasionej składni. Czy to wszystko, co destrukturyzacja ma do zaoferowania? ",
      "id": 1
    },
    {
      "title": "Destrukturyzacja tablic",
      "text": " Skoro znamy już podstawy składni, możemy przejść do ciekawszych sztuczek.\n\nJeżeli chcemy pominąć wybrany element, wstawiamy w jego miejsce przecinek. Pozwala to na selektywne odpakowanie zawartość zwracanej tablicy.\n\nJeżeli zależy nam na przypisaniu kilku elementów i przydzieleniu pozostałej części tablicy do osobnych zmiennych, wystarczy użyć rest operatora.\n\nJeżeli operator nie będzie w stanie odnaleźć żadnej wartości do przypisania, zmienna zostanie pustą tablicą.\n\nTak się składa, że destrukturyzacja tablic wykorzystuje iterator, aby dostać się do wartości źródłowej. Dzięki temu, możemy użyć tej składni dla każdej iterowalnej wartości. Poza tablicami, zaliczamy do nich: łańcuchy, mapy, zbiory oraz struktury zwracane przez operacje nad DOM.\n\nNieudana destrukturyzacja tablicy\n\nJeżeli wykorzystujemy składnię tablicową const [a, b], to przy próbie przypisania z źródła, które nie jest iterowalne, silnik wyrzuca TypeError.\n\nJeżeli nie mamy stuprocentowej pewności co do przetwarzanych przez destrukturyzację wartości (np. funkcje asynchroniczne), należy zachować szczególną ostrożność. ",
      "id": 2
    },
    {
      "title": "Destrukturyzacja obiektów",
      "text": " Nic nie stoi na przeszkodzie, aby nazwa zadeklarowanych zmiennych różniła się od nazw właściwości obiektu, który poddajemy destrukturyzacji. Jednak, wiąże się to z zastosowaniem składni, która początkowo może wydawać się pokrętna.\n\nŚwiat staje na głowie, wszystko na odwrót. Jak widać, po lewej stronie mamy do czynienia z wzorcem źródło -> cel. Tradycyjne przypisanie korzysta z wzorca cel <- źródło. Bez paniki, jak to w programowaniu bywa, po przerobieniu kilku przykładów, wszystko zaskoczy na swoje miejsce.\n\nDestrukturyzacja pozwala na wykorzystanie obliczanych kluczy własciwości. Chodzi tutaj o nazwy właściwości obliczane z wartości zmiennej, co umożliwia notacja nawiasowa [].\n\nNieudana destrukturyzacja obiektu\n\nPodobnie jak w przypadku tablic, musimy uważać na konwersję wartości prymitywnych. Większość z nas jest przyzwyczajona do mechaniki metody Object(). Opakowuje ona wartość prymitywną w odpowiedni obiekt.\n\nPolityka wobec null i undefined jest bardzo liberalna. Sytuacja wygląda inaczej w przypadku metody ToObject(), która jest wykorzystywana za kulisami podczas destrukturyzacji.\n\nDodatkowo, jeżeli rozpoczniemy naszą instrukcję od klamer, silnik zinterpretuje je jako wyznaczenie granic bloku. Chcąc wykorzystać destrukturyzację, warto trzymać się inicjalizacji zmiennych. Jeżeli zależy nam na przypisaniu, możemy wykorzystać obejście z nawiasami. ",
      "id": 3
    },
    {
      "title": "Funkcje strzałkowe",
      "text": "Analiza składni\n\nDefinicja funkcji strzałkowej składa się z listy parametrów, następującego po niej markera => oraz ciała funkcji.\n\nNietrudno zauważyć, że w przypadku funkcji z jednym parametrem, nie pojawiły się przy nim nawiasy otaczające. Jest to jedno z udogodnień składniowych. Jednak, obowiązuje ono tylko, jeżeli parametr jest pojedynczym identyfikatorem. Cóż to oznacza w praktyce? Ano, jeżeli chcemy skorzystać z destrukturyzacji lub wartości domyślnej parametru, to musimy otoczyć go nawiasami.\n\nPrzejdźmy do kolejnej zasadniczej różnicy, dzielącej funkcje strzałkowe od klasycznych deklaracji funkcji i wyrażeń funkcyjnych. Jak widać w powyższych przykładach, oprócz wspomnianego nawiasu, pozbyliśmy się również klamer oraz słowa kluczowego return. Klamry można pominąć w definicjach, których ciało zajmuje jedną linijkę. Konieczność jawnego użycia return jest zależna od zastosowania klamer.\n\nIm mniej linijek kodu, tym mniejsza szansa na wystąpienie błędu. To jedna z najczęściej wygłaszanych opinii przez miłośników czystego kodu. To niewątpliwie jeden z głównych powodów fenomenu funkcji strzałkowych. W większości przypadków pozwalają zrobić tyle samo, pisząc znacznie mniej. Sprawdźmy to na przykładzie. Powiedzmy, że chcemy podnieść do kwadratu wszystkie elementy tablicy, które są parzyste (everyday struggle).\n\nNie uwzględniając pustych linii, pierwsze rozwiązanie zajmuje ich 7, podczas gdy drugie zaledwie 3. Ponadto funkcje strzałkowe, w przypadku prostych wyrażeń, są dużo bardziej czytelne. Możemy skupić pełnię naszej uwagi na operacjach jakie wykonujemy, zamiast przedzierać się wzrokiem przez niepotrzebne klamry i słowa kluczowe.\n\nZobaczmy, jak sprawy się mają w przypadku czegoś bardziej wyszukanego. Weźmy na warsztat funkcję wykorzystującej domknięcia. Skorzystamy tutaj z klasycznego przykładu hodowania funkcji dodającej wybraną wartość do dowolnej liczby.\n\nPo raz kolejny funkcja strzałkowa wyszła zwycięsko z pojedynku z poczciwą deklaracją. Jednak, nie zawsze ta zwięzłość składniowa działa na naszą korzyść. Przy bardziej skomplikowanych funkcjach warto rozważyć, który wariant jest bardziej zrozumiały i czytelny.\n\nWystarczy zachwytów związanych ze składnią funkcji strzałkowych. Na koniec wypadałoby wspomnieć o kilku szczegółach, na które warto uważać.\n\nMarker => musi znaleźć się w tej samej linijce co lista parametrów, w innym przypadku silnik wyrzuci SyntaxError.\n\nJeżeli ciało naszej funkcji zawiera instrukcję, niezależnie od ilości linijek kodu, musimy ją otoczyć klamrami.\n\nDrugim specyficznym przypadkiem, jest funkcja zwracająca literał obiektowy. Aby wszystko poszło zgodnie z planem, musimy otoczyć go nawiasami. W tej sytuacji, zostaną one interpretowane jako operator grupujący dla zwracanego wyrażenia. Pozwala to wykorzystać omówiony wcześniej mechanizm niejawnego return. W przypadku pominięcia nawiasów, klucze naszego obiektu zostaną zainterpretowane jako etykiety, a wartości jako zwykłe łańcuchy.\n\nLeksykalne this\n\nPewnie zastanawiacie się, skąd tyle zachodu z powodu zmiany, która jedynie wpływa na aspekt wizualny naszego kodu. Całe szczęście, główny bohater dzisiejszego wpisu niesie ze sobą dużo istotniejszą zmianę. Komitet TC39 uczynił z funkcji strzałkowych remedium na codzienne cierpienia programistów, którzy mieli dość wywoływania swoich funkcji z dopiskiem .bind(this) oraz korzystania z takich wytrychów jak var self = this.\n\nTradycyjne funkcje posiadają dynamiczne wiązanie this. W dużym skrócie, oznacza to, że wartość this jest zależna od kontekstu wywołania funkcji (temat rozwinę w nadchodzącym wpisie o tym wskaźniku). Taki mechanizm powoduje wiele utrudnień. Zwłaszcza gdy z jakiegoś powodu chcemy utworzyć obiekt dodający wybraną wartość, gdzie tylko język pozwoli (everyday struggle part 2).\n\nNiestety, z takim kodem, nasz ambitny plan spali na panewce. W strict modecode>, wskaźnik this wewnątrz metody map przyjmie wartość undefined. Z pominięciem strict mode, odwoła się on do obiektu globalnego Windowcode>. W tym przypadku, nasza funkcja wypluje z siebie [NaN, NaN], a my zaczniemy się zastanawiać, czy programowanie w JSie, aby na pewno było dobrym pomysłem.\n\nOczywiście, programiści tworzą Addery na całym świecie. Geniusze na miarę Richarda Hendricksa szybko zorientowali się, że jest sposób na poprawne powiększenie elementów wybranej tablicy o ich ulubioną wartość. Wystarczy skorzystać jeden z wcześniej wspomnianych wspomagaczy.\n\nZasadniczym minusem tych rozwiązań, zwłaszcza jeżeli nasza partnerka jest programistką, jest utrata elegancji naszego kodu. Kilka takich funkcji i usłyszymy, że nie robimy tego tak dobrze jak kiedyś. Mimo że nie mam takiego problemu, to dbam o los kolegów z branży. Mam do zaoferowania znacznie lepsze rozwiązanie.\n\nWskaźnik this przyjmuje wartość zgodną z oczekiwaniami, ponieważ funkcje strzałkowe posiadają zakres leksykalny. Jak działa zakres leksykalny? Po raz kolejny, w dużym skrócie, jeżeli identyfikator nie zostanie odnaleziony w aktywnym zakresie, jest on wyszukiwany w zakresie otaczającym.",
      "id": 4
    },
    {
      "title": "Kiedy NIE używać funkcji strzałkowych",
      "text": "Zanim odjedziemy do stacji strzałkowego hype’u, warto zastanowić się, czy faktycznie mamy do czynienia z rozwiązaniem niezawodnym. Czyżby słowo kluczowe function wybierało się na emeryturę? Spoiler alert: nic bardziej mylnego.\nKonstruktory\n\nWracając do naszego Addera, moglibyśmy pokusić się o przepisanie funkcji konstruującej z użyciem strzałki.\n\nCzybyżby funkcje strzałkowe były wybrakowane w stosunku do swoich poprzedników? Na to wygląda. Zwykłe funkcje obsługują new za pomocą wewnętrznej metody [[Construct]] oraz właściwości prototype. Funkcje strzałkowe nie posiadają żadnej z nich, stąd zaobserwowany błąd.\nMetody\n\nKolejny psikus czeka nas w przypadku metod. W tym przypadku, dokładnie ten sam mechanizm, który zmuszał nas do stosowania .bind(this), jest nam na rękę.\n\nWskaźnik this w metodzie getLikes() wskazuje na obiekt globalny Window. Jest to spowodowane brakiem utworzenia własnego wiązania this i wyszukiwaniem w zakresie leksykalnym. Nic straconego, sukces na social-media i tak mam zagwarantowany. Funkcja ustawiająca ilość lajków działa jak należy ;).\nObsługa zdarzeń\n\nAnalogicznie do metod, sytuacja powtarza się przy nasłuchiwaniu zdarzeń na elementach DOM.\n\nFunkcje wykorzystujące obiekt arguments\n\nTablico-podobny obiekt arguments przechowuje wszystkie argumenty przekazane do zadeklarowanej funkcji lub wyrażenia funkcyjnego. Niestety, na próżno szukać go wewnątrz funkcji strzałkowej. Funkcje strzałkowe nie wiążą własnego this, arguments, super oraz new.target. Jeżeli chcemy w naszej funkcji strzałkowej odwoływać się do wszystkich przekazanych argumentów, musimy skorzystać z spread operatora.\nJak żyć?\n\nMiało być tak pięknie, wyszło jak zwykle. Biorąc pod uwagę wymienione wyjątki, kiedy można ze spokojem korzystać z funkcji strzałkowych? Proponuję tutaj podejście zaproponowane przez Larsa Schöninga na stackoverflow:\n\n    Wykorzystuj function w zakresie globalnym oraz dla właściwości Object.prototype.\n    Wykorzystuj class dla konstruktorów obiektów.\n    Wykorzystuj => w każdym innym przypadku.\n\nJeżeli takie podejście do Ciebie nie przemawia, możesz zawsze skorzystać z niezawodnego, lecz w moich oczach karykaturalnego wykresu, zaproponowanego przez Kyle’a Simposona.",
      "id": 5
    },
    {
      "title": "Prototypy i dziedziczenie",
      "text": "Dziedziczenie klasowe\n\nPostrzegając ten problem przez pryzmat języków obiektowych zorientowanych na klasy, zanim przejdziemy do wytwarzania, musimy przygotować specyfikację produktu.\nRolę specyfikacji będzie stanowiła klasa Krzesło. Zamieścimy w niej wszystkie właściwości i funkcjonalności krzeseł, które będziemy produkować. Najpierw skupimy się na najprostszym modelu, jaki przychodzi nam do głowy, zostawiając sobie furtkę do dalszych usprawnień w przyszłości.\n\nMając do dyspozycji taki plan, wystarczy wydzielić odpowiednią ilość zasobów i możemy zabierać się do pracy. Wychodzimy z założenia, że każdy egzemplarz powinien być idealnym odzwierciedleniem przygotowanej specyfikacji. Stąd, mówi się, że wyprodukowane przez nas krzesła są instancjami klasy Krzesło.\n\nJeżeli chcielibyśmy stworzyć nowy model krzesła, nie musimy tracić czasu na tworzenie zupełnie nowej specyfikacji. Krzesła dzielą ze sobą wiele cech charakterystycznych, niezależnie od różnic w szczegółach. Każde z nich będzie miało cztery nogi, siedzenie i oparcie, a jego głównym przeznaczeniem będzie możliwość zajęcia na nim miejsca. Wszystkie te cechy są opisane w naszej klasie Krzesło.\n\nMożemy uznać nasz pierwotny projekt za punkt wyjścia. Wystarczy go skopiować, nanieść na niego innowacyjne zmiany, i voila – mamy do dyspozycji nowy produkt. Taki proces nazywamy dziedziczeniem klasowym.\nDziedziczenie prototypowe\n\nJeżeli zdecydujemy się na podejście prototypowe, zabierzemy się za ten problem zupełnie inaczej. Wychodzimy z założenia, że proces produkcji pierwszego egzemplarza dostarczy nam know-how, które pozwoli na sprawną produkcję kolejnych. Nie będziemy tracić czasu na tworzenie specyfikacji. Bierzemy materiały, instrukcję z IKEA (lub zaprzyjaźnionego bloga programistycznego) i po chwili jesteśmy posiadaczami prototypu krzesła.\n\nTo krzesło, konkretny obiekt, będzie stanowiło wzór dla wszystkich następnych krzeseł.\nTakie nastawienie, ignorujące rygor przestrzegania specyfikacji, daje nam możliwość późniejszego nanoszenia modyfikacji. Tworząc kolejne krzesła, interesują nas tylko nowości w stosunku do prototypu. W razie wątpliwości co do własności produktu, wystarczy zerknąć na jego prototyp. Takie odwoływanie się do prototypów, wskazywanie ich za pomocą referencji, nazywamy łańcuchem prototypowym. Wykorzystywanie własności prototypu nazywamy dziedziczeniem prototypowym.\n\nWarto wiedzieć: Słowo kluczowe class pojawiło się w składni języka dopiero za sprawą ES6. Jest to jedynie upiększenie składni, które w ostateczności sprowadza się do wykorzystywania prototypów.\nPrototypy w JS\n\nKażdy obiekt w momencie utworzenia otrzymuje ukrytą właściwość [[Prototype]]. Może ona przyjąć dwie wartości: null\nlub referencję do obiektu nazywanego prototypem. Jeżeli spróbujemy odwołać się do właściwości, która nie zostanie odnaleziona w obiekcie, silnik będzie kontynuował poszukiwania, w obiekcie wskazywanym przez [[Prototype]].\nJeżeli właściwość zostanie odnaleziona w prototypie, silnik zwróci przypisaną do niej wartość, tak jakby znajdowała się w naszym obiekcie od samego początku.\n\nPodczas swoich poszukiwań silnik nie zatrzymuje się na bezpośrednim prototypie naszego obiektu. Przemierzy on cały łańcuch prototypów. Będzie szukał w prototypie prototypu etc., aż do momentu natrafienia na [[Prototype]] z wartością null.\nDomyślnie ostatnim ogniwem łańcucha prototypów jest Object.prototype. Jeżeli wyszukiwana właściwość nie zostanie odnalezionaw w żadnym z przeszukiwanych obiektów, to silnik uraczy nas wartością undefined.\n\nJak w przypadku wszystkich ukrytych właściwości, nie mamy możliwości bezpośredniej interakcji z [[Prototype]].\nJako interfejs służą nam metody obiektu globalnego Object.\nObject.getPrototypeOf(obj) zwraca referencję do [[Prototype]], podczas gdy Object.setProtytypeOf(obj, proto) pozwala ustawić prototyp obj na obiekt proto.\n\nJeżeli chcemy ustawić prototyp obiektu w momencie jego inicjalizacji, należy wykorzystać Object.create(proto, objectProperties). Ta metoda zwróci nam nowy obiekt z właściwością [[Prototype]] wskazującą na proto.\n\nCzasami zależy nam na sprawdzeniu, czy obiekt posiada swoją prywatną właściwość, czy uzyskuje do niej dostęp z\nłańcucha prototypów. W tym wypadku wykorzystuje się metodę Object.hasOwnProperty(obj, prop).\n\nTyle z suchej teorii, przejdźmy do analizy kodu. Przygotowałem dla Was dwie wersje prostego programu generującego obiekty graczy NBA. Pierwsza z nich jest zaimplementowana w oparciu o wzorzec dziedziczenia prototypowego. Druga wersja zawiera alternatywny wzorzec, delegację zachowań.\n\nZanim przejdziemy dalej, upewnij się, że rozumiesz, jak działa wskaźnik this w JS. Dodam tylko, że prototypy nie mają żadnego wpływu na wartość tego wskaźnika.\n",
      "id": 6
    },
    {
      "title": "Wskaźnik this w JavaScript",
      "text": "W JavaScript wiązanie this jest zależne od kontekstu wywołania funkcji. Wyróżnia się pięć takich kontekstów: domyślny, niejawny, jawny, twardy, konstrukcyjny. Oczywiście może dojść do konfliktu kilku kontekstów, stąd musimy znać ich hierarchię. To nie wszystko, tryb restrykcyjny (strict mode) również ma istotny wpływ na działanie wskaźnika this.\n\nJak widać, mamy do czynienia z nie lada szataństwem. Nie pozostało nam nic innego jak zarzucić na nie łańcuchy doświadczenia i zaciągnąć do pracy w naszym kodzie. Bez zrozumienia wszystkich wspomnianych mechanizmów nie będziemy w stanie poczynić postępów w programowaniu obiektowym. this to absolutny fundament tego paradygmatu. Pozwala na zrezygnowanie z jawnego odwoływania się do obiektu. Stąd już krótka droga do wszechstronnych funkcji, które, bez dodatkowych modyfikacji, będą sobie radziły z różnymi parametrami.\n\nEfektywna praca z this w JavaScript wymaga znajomości trzech metod. Dzięki nim możemy w jawny sposób wskazać, z jaką wartością ma być związane this. Wspomniane metody to: Function.prototype.call, Function.prototype.apply i Function.prototype.bind.\n\nFunction.prototype.call wywołuje funkcję z wartością this wskazaną w pierwszym parametrze. Resztę parametrów, przekazywanych do wywoływanej funkcji, przyjmuje indywidualnie. Function.prototype.apply, kuzyn call, ma takie samo działanie na this, ale resztę parametrów przyjmuje jako tablicę.\n\nFunction.prototype.bind zwraca nowy egzemplarz funkcji. Przy wywołaniu, wiązanie this będzie trwale wskazywało na wartość, przekazaną podczas tworzenia funkcji.",
      "id": 7
    },
    {
      "title": "Domknięcia ",
      "text": " Domknięcie to funkcja, która pamięta swoje otoczenie leksykalne i może uzyskać do niego dostęp. W JS każda funkcja jest domknięciem, ponieważ przechowuje informacje o swoim środowisku leksykalnym dzięki ukrytej właściwości [[Environment]].\n\nJak ta definicja przekłada się na pracę z kodem? Już podczas stawiania pierwszych kroków z JS, intuicyjnie wykorzystujemy możliwość odwoływania do zmiennych globalnych z poziomu funkcji.\n\nCzy jesteśmy tego świadomi czy nie, najprostsze domknięcia towarzyszą nam od samych początków programowania. To właśnie funkcja połączona z możliwością odwoływania się do zakresów zewnętrznych stanowi istotę domknięcia. Można powiedzieć, że funkcja domyka się na zakresie otaczającym podczas wyszukiwania zmiennej.\n\nAby taka mechanika miała ręce i nogi, silnik zamraża zakres funkcji otaczającej, nawet jeżeli minęło dużo czasu od jej wykonywania. Stan zmiennych jest przechowywany w pamięci, dopóki istnieje funkcja, która domyka się na tym zakresie.\n\nNajłatwiejszym sposobem doprowadzenia do takiej sytuacji jest zwrócenie przez funkcję otaczającą nowej funkcji lub obiektu z referencją do funkcji zagnieżdżonej. Pozwala to na tworzenie modułów wykorzystujących hermetyzację danych. Mamy pełną kontrolę nad interfejsem naszego kodu. ",
      "id": 8
    },
    {
      "title": "Var vs Let vs Const ",
      "text": "Hoisting\n\nZmienne w JavaScript podlegają zjawisku o nazwie podnoszenia czy windowania (ang. hoisting). Co to w ogóle oznacza? Najprościej wytłumaczyć to tak, że JavaScript przenosi deklaracje zmiennych zainicjowanych na początek funkcji.\n\nZerknijmy na następujący przykład:\n\nKonsola wyświetli wynik 5, chociaż najpierw przypisaliśmy wartość do zmiennej,\na dopiero później ją zadeklarowaliśmy.\n\nWindowaniu podlegają tylko deklaracje, a nie przypisanie wartości do zmiennych.\n\nWarto podkreślić, że zmienne deklarowane za pomocą „var” czy „function” są inicjalizowane od razu i przypisaną mają wartość undefined. Za to zmienne „let”\nczy „const” są inicjalizowane podczas definicji zmiennej. Dokładnie wyjaśnia to poniższy przykład:\nZmienna o zasięgu blokowym\n\nJeśli chcemy mieć zmienne o zasięgu blokowym, to mamy do wyboru dwa typy: „let”\noraz „const”. Dla wielu programistów jest to rozwiązanie bliższe „sercu”, niż zmienna\no zasięgu funkcyjnym.\n\n„let”, w skrócie, to blokowy odpowiednik „var”.\n\n„const” za to reprezentuje stałą. Podczas deklaracji zmiennej musimy od razu przypisać jej wartość, której później nie można zmienić.\nDziałanie\n\nW podanym przykładzie, programu zmienia swoje zachowanie w porównaniu do wersji z „var”. W każdym bloku deklarujemy nową zmienną x, jednak nie nadpisuje ona wartości zmiennej o tej nazwie, zdefiniowanej w bloku „wyżej”.\n\nIdentyczna sytuacja będzie, gdy słowa „let”, zamienimy na „const”.\n\nOczywiście możemy odwoływać się do zmiennych typu „let” czy „const” w blokach zagnieżdżonych.\n\nNa koniec ostatni przykład z zastosowania „let” oraz „var” w jednej funkcji.\n\nZmienna zdefiniowana za pomocą „let” przyjmuje swoją wartość, tylko w swoim bloku. Nie zakłóca przez to działania dalszego kodu.\n\nZastanówmy się nad odwrotną sytuacją- najpierw definiujemy x jako „let”, a w bloku if jako „var”. Takie działanie nie będzie poprawne. Dlaczego? To już zostawiam do samodzielnego zastanowienia się 🙂\nPodsumowanie\n\nOdpowiednie stosowanie „var”, „let” oraz „const” pozwoli nam uniknąć wielu błędów, które są dość trudne do odnalezienia.",
      "id": 9
    },
    {
      "title": "Obietnice",
      "text": " Czym są Obietnice?\n\nObietnice to specjalny obiekt. Jak to z obiektami bywa, można je utworzyć za pomocą konstruktora. Konstruktor Obietnicy jako parametr przyjmuje funkcję o dwóch argumentach: resolve i reject. Aby spełnić obietnicę, wewnątrz tejże funkcji, wywołujemy resolve(value). value to wartość, którą chcemy przekazać do procedury obsługi. Jeżeli chcemy odrzucić obietnicę, to wywołujemy reject(error). Jako error możemy przekazać dowolną wartość podobnie jak w przypadku resolve. Jednakże dobrą praktyką jest zwracanie obiektu błędu lub chociaż wiadomości opisującej powód odrzucenia obietnicy. Przed spełnieniem lub odrzuceniem, obietnica jest w stanie oczekującym.\n\nObietnice mają dwie wewnętrzne właściwości: stan i wartość zwrotną. Stan Obietnicy początkowo jest ustawiony na ‚oczekująca’ (pending). W przypadku wywołania resolve(), stan zmienia się na ‚wywiązana’ (fulfilled). Analogicznie, reject() sprawia, że mamy do czynienia z ‚odrzuconą’ (rejected Obietnicą. Wartość zwrotna to wartość zwracana przez Obietnicę, czyli argument przekazany do dwóch wcześniej wymienionych metod.\n\nJeżeli wykorzystujemy wewnętrzną metodę resolve(value), która oznacza pomyślne wykonanie zadania, to ustawiamy właściwości:\n\n    Stan na ‚wywiązana’\n    Wartośc zwrotna na value\n\nJeżeli wykorzystujemy wewnętrzną metodę reject(error), która oznacza wystapienie błędu podczas wykonywania zadania, to ustawiamy właściwości:\n\n    Stan na ‚odrzucona’\n    Wartość zwrotna na error\n\nUtworzenie obietnicy to dopiero początek, musimy ją jeszcze wykonać. Aby to zrobić, wystarczy wywołać ją jak każdą funkcję. W następstwie wywołania obietnicy, otrzymujemy dostep do procedury obsługi .then(). Przyjmuje ona dwa argumenty, każdy z nich to funkcja przechwytująca wartość przekazaną przez Obietnicę. Pierwsza z nich zostanie wywołana w przypadku wywiązania się z obietnicy (zastosowanie resolve()), druga z nich w przypadku błędu (zastosowanie reject()).\n\nAby zwiększyć czytelność kodu, możemy wykorzystać drugą procedurę obsługi, .catch. Zastępuje ona drugą funkcję przekazywaną do .then() – tę, która służy do przechytywania błędu. To follow-up do bloku try/catch.\n\nKod funkcji przekazanej do obietnicy, jest wykonywany automatycznie i natychmiastowo, w momencie utworzenia nowej obietnicy za pomocą konstruktora new Promise.\nWywołanie resolve() bądź reject() jest równoznaczne z zastosowaniem słowa kluczowego return w normalnej funkcji. Silnik zwraca wartość i przechodzi do wykonywania kolejnej funkcji ze stosu. Stąd nie ma możliwości wywiązania i odrzucenia tej samej Obietnicy.\n\nWarto wiedzieć: mimo że możemy przekazać do reject jakąkolwiek wartość, to preferowane jest zwracanie obiektów połączonych prototypowo z Error.\nProcedury obsługi: .then() i catch()\n\nDziałanie procedur obsługi Obietnicy świetnie obrazuje poniższy przykład. Za jego pomocą możemy dołączyć dowolny skrypt do nagłówka strony.\n\nDopóki Obietnica jest w stanie oczekującym, to procedury .then() i .catch() czekają na wartość zwrtoną. Po jej przekazaniu, dochodzi do wywołania jednej z procedur.\n\nTak to wygląda w przypadku kodu asynchronicznego. Nic nie stoi na przeszkodzie, aby Obietnica obsługiwała synchroniczną funkcję. Tym razem procedury wykonają się natychmiastowo.\n\nTutaj warto zaznaczyć, że same funkcje przekazane do .then()/.catch() zawsze są wykonywane asynchronicznie. Trafiają one do wewnętrznej kolejki wykonywania funkcji. Silnik JS pobiera kolejne funkcji z kolejki i wykonuje je po zakończeniu działania obecnie wykonywanego kodu. Działa to na podobnej zasadzie jak setTimeout(…, 0).\n\nJedną z niebywałych zalet obietnic jest możliwość wykorzystywania return – w ten sposób rezygnujemy z niepożądanego wykorzystywania efektów ubocznych.\n\nCo możemy zwrócić wewnątrz .then()?\n\n    Kolejną Obietnicę\n    Wartość zwrotną\n    Wyrzucić błąd za pomocą throw\n\n1. Zwracanie Obietnicy.\n\n2. Zwracanie wartości.\n\nNie jesteśmy ograniczeni do zwrócenia obietnicy, jeżeli mamy dostęp do danych bez wykonywania zapytania – zróbmy to.\n\n3. Wyrzucenie błędu za pomocą throw.\n\nW ten sposób możemy wyrzucić błąd z wartością synchroniczną. Spowoduje to przechywycenie błędu przez metodę .catch().\n\nŁańcuchownie Obietnic\n\nWspomniana w wstępie piramida zagłady pojawia się w przypadku ciągłego przekazywania wartości zwrotnej jednej funkcji asynchronicznej do kolejnej. W przypadku Obietnic możemy utworzyć sekwencję .then() i .catch() o dowolnej długości.\n\nJeżeli obietnica zostanie wykonana, to przechodzimy do kolejnego .then(). W przypadku błędu przechodzimy do najbliższego .catch().\nPromise.all()\n\nPrzypuśćmy, że zależy nam na wywołaniu kilku Obietnic, jedna po drugiej. Nastepnie chcemy przeanalizować czy wszystko poszło zgodnie z planem. Najbardziej intuicyjnym rozwiązaniem byłoby obsłużenie wartości przechowywanych w tablicy za pomocą forEach.\n\nW takiej sytuacji nasza funkcja zwraca undefined. Gdybyśmy dodali return w forEach, nic by się nie zmieniło. Kod wewnątrz forEach to zwykły callback, ma swój własny zakres.\n\nCo nas interesuje to return Promise.all(). W ten sposób zgodnie z oczekiwaniami zareagujemy na wywiązanie/zerwanie wszystkich obietnic.\n\nJeżeli chcemy jednocześnie wykonać kilka obietnic i zareagować na to czy wszystkie zostały wykonane, to powinniśmy posłużyć się Promise.all(). Metoda ta zwraca Obietnicę tylko jeżeli wszystkie Obietnice przekazane w parametrze (jako tablica, stąd zastosowanie .map() zamiast .forEach()) zostały wywiązane. Jeżeli jakakolwiek z Obietnic zostanie odrzuca, wywoła się procedura .catch().\nNa co uważać stosując Obietnice?\n\nObietnice są czymś co ma uchronić nas od callbackowego piekła, a nie służyć za nakładkę składniową, z której nie wynika żadna poprawa w czytelności kodu.\n\nAby ustrzec się przed takim kodem, stosujmy łańcuchowanie i kompozycję Obietnic.\n\nWarto pamiętać o umieszczaniu chociażby jednej procedury .catch(). Bez tej metody nie dość, że nie przechwycimy żadnego błędu, to na dodatek nie będziemy świadomi ich wystąpienia – nie wyswietlą się nawet w konsoli.\nCallbacki vs Obietnice – porównanie.\n\nOkej, skoro udało nam się rozbudować wiedzę o Obietnicach to sensownym podsumowaniem byłoby porównanie czym tak naprawdę różnią się od callbacków.\n\nCallbacki:\nMusimy mieć gotowy callback w momencie wywoływania kodu asynchronicznego. Innymi słowy, musimy wiedzieć co zrobić z wynikami przed przystąpieniem do działania.\nNasz kod asynchroniczny może obsługiwać tylko jeden callback.\n\nObietnice:\nObietnice pozwalają na kodowanie czynności w naturalnym porzadku. Pierw wywołujemy funkcję wykonującą zapytanie. Następnie, rezultatem zajmujemy się wewnątrz procedur obsługi .then() i catch(). Możemy wywołać .then() na jednej obietnicy ile razy chcemy – taki zabieg nazywamy łańcuchowaniem Obietnic. Jeżeli zależy nam na zbiorczej obsłudze kilku zapytań, możemy wykorzystać Promise.all().\nPodsumowanie\n\nTyle na temat Obietnic. Udało nam się przerobić kolejny naprawdę istotny element ES6. Początkowo wydawało mi się, że temat jest naprawdę skomplikowany i trudno było mi się w tym wszystkim połapać. Mam nadzieję, że Wy nie macie takiego wrażenia po przeczytaniu tego wpisu.\n\nZachęcam do śledzenia bloga na facebooku. Zapraszam do wspólnego ćwierkania na Twitterze.\n\nW przyszłym tygodniu ostatni (!) wpis omawiający nowinki z ES6, tym razem zajmiemy się modułami. ",
      "id": 10
    }
  ]
}